Architectural Style: Lucid Composite Architecture (LCA)1. Executive SummaryLucid Composite Architecture (LCA) is a structural design philosophy prioritizing strict containment, radical composition, and an evolutionary approach to system lifespan. It rejects the "one-size-fits-all" abstraction model, instead advocating for a dual-state existence: generic and simple by default, yet ruthlessly performant and complex where mandated by context.LCA treats software not as a monolith or a web of microservices, but as a hierarchy of isolated Strata built from Composite Atoms, underpinned by functional thinking and universal data modeling.2. Core Philosophy & Tenets2.1 Composition Over Inheritance (Absolute)In LCA, inheritance is viewed as a rigid coupling mechanism to be avoided. Behavior is never inherited; it is composed.The Rule: If an object needs functionality, it must contain a component that provides it. It never is that functionality.The Result: Systems are assembled like complex machinery. You can swap the engine without changing the chassis.2.2 Radical Containment (The Air-Gap Principle)Modules within the system must operate under the assumption of "hostility."Failure Containment: If a sub-module crashes or throws an exception, it must be contained within its own boundary. It should not destabilize the parent composite.Scope Isolation: Variables and logic inside a composite are invisible to the outside world unless explicitly exposed via a Conduit.2.3 Functional Thinking & ImmutabilityLCA mandates a shift from stateful OOP to functional paradigms.Immutable by Default: Data is never mutated in place. State changes are represented by creating new versions of data structures. This eliminates race conditions and makes the system trivially testable and time-travel debuggable.Pure Transformations: Components should be viewed as pipelines (Input -> Transformation -> Output). Side effects (I/O, database writes) are pushed to the boundaries of the system, keeping the core logic pure.Library-First Enforcement: Functional concepts are not left to convention. They must be enforced by strongly-typed libraries appropriate for the language ecosystem.Dart / Flutter: Adoption of libraries like fpdart (for Option, Either, Task) and freezed (for immutable unions/data classes).Python: Adoption of libraries that enforce functional typing and immutable structures (e.g., returns for monads, immutables for collections) to ensure type safety.2.4 The "Simplicity Default" vs. "The Performance Tunnel"This is the defining characteristic of LCA.The Default: 80% of the architecture should rely on "Generic Simplicity." Use standard list processing, readable transformations, and clear composition.The Tunnel: When profiling data proves a bottleneck, LCA explicitly sanctions "Necessary Complexity." Developers are encouraged to tunnel through the abstraction to write low-level, hardware-sympathetic code (e.g., memory arenas, bit-masking, zero-copy buffers), provided this code is encapsulated behind the standard generic interface.3. Structural AnatomyThe style is defined by distinct structural components:3.1 The Atom (The Leaf Node)The smallest unit of the architecture.Characteristics: Pure functions or immutable objects. Highly testable.Complexity: This is where the "Low-Level" solutions live. An Atom might be a complex mathematical model written in C or Rust for speed, but it exposes a simple calculate(input) interface.3.2 The Composite (The Container)The structural glue that holds Atoms together.Role: The Composite does not perform business logic; it orchestrates Atoms. It routes data from Atom A to Atom B.Design: Generic. It looks the same regardless of the specific business domain. It manages lifecycles and dependencies.3.3 The Conduit (The Distributable Boundary)The standardized boundary between Deployable Units.Location Transparency: Conduits represent boundaries that cross between independent units (network/process).Protocol Buffers & Versioning: The mandatory mechanism for defining Conduits is Protocol Buffers. All Conduits are explicitly Versioned (e.g., v1.PricingService). This guarantees that deployments can be split and asynchronous; a new producer can support old consumers.3.4 The Deployable Unit (The Service)The physical manifestation of the architecture at runtime.Focused Scope: A Deployable Unit contains a limited set of steps, running in a synchronous or asynchronous fashion. It is highly focused on a specific domain capability.Idempotency: All units are designed to be Idempotent by Default. Retrying an operation must be safe.Internal Composition: The hierarchy of "Composites" and "Atoms" described above exists within this unit. The unit is the "Host" for the composition.4. Data Strategy: The Universal GraphLCA rejects ad-hoc data structures in favor of semantic interoperability.4.1 Graph-Based ModelingData should be conceptualized not as rigid tables, but as a graph of interconnected entities.Graph Thinking: Relationships are first-class citizens. Whether stored in a Relational DB, a Graph DB, or in-memory, the domain model reflects a graph where entities (nodes) are linked by semantic relationships (edges).4.2 Boundary Semantics: Schema.org & AI InteropAt the edges of the system—where data meets the outside world, AI agents, or LLMs—the architecture mandates the use of standard ontologies.Schema.org as the Lingua Franca: Public APIs and Agent interfaces utilize Schema.org types (typically serialized as JSON-LD or Protobuf maps). This ensures that the system is self-describing to automated consumers.Extension Mechanisms: When the standard ontology does not cover a specific domain concept, standard extension mechanisms must be used rather than inventing proprietary root types.4.3 Internal Modeling: Single Subject Data TypesInside the "Air-Gap" of the application logic, the architecture prioritizes precision over broad standardization.Single Subject Types: Internal data structures are modeled as Single Subject Data Types. These are minimal, focused structures designed to be consumed by specific pure functions. They contain exactly the data needed for the computation and nothing more.Decoupling: Internal types are not required to mirror Schema.org definitions. This prevents the "bloat" of public standards from slowing down internal logic.The Mapping Layer: A specific set of pure functions exists solely to map these efficient internal types to their semantic Schema.org equivalents at the egress Conduit.5. The Temporal Strategy: Today vs. TomorrowLCA is designed to be Evolutionary. It assumes that the code written today will be tech-debt tomorrow, and plans for its deletion.5.1 Interface Stability & Aggressive RefactoringThe architecture prioritizes the Stability of the boundary over the longevity of the code behind it.Immutable Interfaces: Once a Conduit (Interface) is published and consumed, it is Immutable. Any change to the contract requires a new version (e.g., v1 -> v2). This supports split deployments, ensuring that changes to a service do not break existing clients.Aggressive Refactoring: Behind the stable interface, developers are encouraged to refactor aggressively. Because the boundary is air-gapped and versioned, the internal implementation (the "Composites" and "Atoms") can be completely rewritten, optimized, or replaced without fear of breaking upstream dependents.Legacy Encapsulation: Legacy systems are treated as just another "Atom." They are wrapped in a Conduit, contained, and interacted with, preserving the integrity of the modern system.6. Architectural Rules & ConstraintsDimensionRuleRationaleDependenciesUni-directional FlowCycles create rigid coupling; flow must go down or across, never up.Data StateEnforced ImmutabilityUse strongly-typed libraries (fpdart, immutables) to prevent accidental mutation.ProtocolProtocol BuffersEnforces strict contracts at distributable boundaries (Conduits).ModelingInternal Focus / External StandardsUse focused Single Subject Types internally; map to Schema.org at boundaries.RefactoringStable Interface / Aggressive RefactorInterfaces are immutable/versioned. Implementations are ephemeral and can be rewritten freely.7. Implementation ScenariosScenario A: High-Frequency Trading ModuleContext: Requires extreme low latency.LCA Approach: The core calculation engine is an Atom written in distinct, unsafe, optimized code (The Performance Tunnel). It inputs and outputs Protocol Buffers to ensure type safety at the boundary. The rest of the system sees a generic "PriceCalculator," unaware of the complexity inside.Scenario B: Knowledge Graph EngineContext: Requires linking diverse data types (Users, Products, Reviews).LCA Approach: The data model is defined using Schema.org types at the API boundary to allow AI agents to query it. Internally, the "Storage Atom" uses highly optimized, minimal nodes ("Single Subject Types"). A mapping layer transforms the internal graph node Node{id:1, v:3.2} into Schema.org/Product only when requested by an external consumer.8. Architectural Documentation ApproachThis documentation system is designed for dual consumption by both AI coding assistants and human engineers. It prioritizes navigability, explicit uncertainty, and progressive elaboration over comprehensive upfront documentation.8.1 Hierarchical StructureDocumentation mirrors the structural hierarchy of the system. Navigation headers (e.g., ↑ Parent, ↓ Children, ← Siblings) create a traversable graph.Platform Level: High-level architectural vision and cross-cutting concerns.Repository Level: Scope and context of the specific code repository.Application/Service Level: Service-specific logic and boundaries.Component Level: Deep implementation details living in child documents.8.2 Maturity-Aware ContentA four-tier status system is used to signal the trust level of the documentation:StatusTrustDescriptionDraftHypothesisNot yet reviewed; ideas are tentative.InProgressDirection SetActively evolving; core direction is established.StableReliableReviewed and reliable; safe to build against.LockedProduction VerifiedProduction-proven; change requires an ADR.8.3 Inline Quality MarkersTo allow for progressive refinement without blocking publication, inline annotations flag gaps:[*Needs Resolution][*Needs More Depth][*Needs Verification]8.4 Decision Records (ADRs)Architectural decisions are captured in a structured format and are append-only (never deleted, only superseded).Context & Drivers: Why are we making this decision?Options Considered: What alternatives were rejected?Explicit Trade-offs: Detailed positive, negative, and neutral consequences.8.5 Diagrams as Code & Visual ScalabilityAll diagrams utilize Mermaid. To prevent visual complexity issues ("spaghetti diagrams"), the architecture relies on the Hierarchical Structure defined in 8.1.Scoped Complexity: A diagram must only depict concepts relevant to its specific level in the hierarchy (Platform, Service, or Component).Drill-Down Navigation: High-level diagrams link to child documents for deeper details, rather than exploding all complexity in one view.Mermaid Benefits:Version Control: Diagrams evolve alongside prose in Git.AI Readability: Assistants can parse and edit the diagrams.Consistency: Uniform rendering across all tools.8.6 Naming ConventionsARCHITECTURE.md (uppercase): The authoritative root document.architecture.md (lowercase): Inherits from the parent directory's documentation.adr-NNN-{slug}.md: Numbered Architectural Decision Records.{topic}.md: Focused topic documents (e.g., concurrency.md, security.md).9. ConclusionLucid Composite Architecture is a pragmatic style for engineers who value clarity and engineering rigour. By enforcing immutability, utilizing Protocol Buffers, grounding data in open ontologies, and maintaining a strict, AI-friendly documentation protocol, it ensures that the system is not only robust and performant today but semantically ready for the interconnected future.
