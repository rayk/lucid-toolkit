# @docs execution-plan.md (read only if field details needed)

@type: ItemList
@id: execution-plan-{spec-id}
name: Execution Plan
description: Implementation tasks derived from {spec-name}
dateCreated: {iso-datetime}
executionLog: {path-to-execution-log}
status: Draft

# Project context for all agents
projectRoot: {absolute-path-to-project}
architectureRef: {path-to-adr-or-constraints}

source:
  @type: TechArticle
  @id: {spec-id}
  name: {spec-name}
  url: {spec-path}
  version: {spec-version}

metadata:
  @type: Thing
  @id: {spec-id}-meta
  totalPhases: {P}
  totalTasks: {N}
  estimatedTokens: {total-tokens}
  successProbability: {0.0-1.0}
  estimatedModels:
    haiku: {haiku-count}
    sonnet: {sonnet-count}
    opus: {opus-count}

commitMessage: |
  {type}({scope}): {description}

  - {phase-1-commitSubject}
  - {phase-2-commitSubject}
  - {phase-N-commitSubject}

  Refs: {spec-id}

phases[{P}]: {phase-id-1},{phase-id-2},...,{phase-id-P}

# Agent Reference (fully-qualified names for executor dispatch)
# ──────────────────────────────────────────────────────────────
# impl-flutter:flutter-coder     — Domain, application, simple widgets, tests (sonnet)
# impl-flutter:flutter-ux-widget — Visual widgets, animations, a11y (opus)
# impl-flutter:flutter-e2e-tester — E2E tests, integration tests (opus)
# impl-flutter:flutter-verifier  — Code review, architecture compliance (opus)
# Explore                        — Codebase exploration (haiku, builtin)
# general-purpose                — Multi-step research (sonnet, builtin)

{phase-id}:
  @type: Phase
  @id: {phase-id}
  name: {phase-name}
  description: {phase-description}
  order: {1..P}
  category: {category}
  commitSubject: {single-line-summary}
  estimatedTokens: {tokens}
  varianceBudget: {percent}

  # Agent column uses fully-qualified names: impl-flutter:flutter-coder
  tasks[{N},]{@type,@id,name,type,complexity,model,agent,tokens,variance,parallelGroup,status}:
    Action,{task-id},{task-name},{type},{complexity},{model},{agent},{tokens},{%},{group},PotentialActionStatus

  taskDetails[{N},]{taskId,description,acceptance}:
    {task-id},{description},{acceptance-criteria}

  # taskInputs: paths only (executor reads file contents OR passes paths to agent)
  taskInputs[{I},]{taskId,source,ref}:
    {task-id},{source},{ref}

  taskOutputs[{O},]{taskId,path,type}:
    {task-id},{path},{type}

  # taskReturns: minimal data only (≤500 tokens per task)
  taskReturns[{R},]{taskId,key,valueType,description}:
    {task-id},{key},{valueType},{description}

  # agentInputs: agent-specific required inputs (executor constructs prompt from these)
  # ────────────────────────────────────────────────────────────────────────────────────
  # For flutter-coder: projectRoot, targetPaths, architectureRef, spec
  # For flutter-ux-widget: projectRoot, targetPaths, architectureRef, designSpec, spec
  # For flutter-e2e-tester: projectRoot, userFlowSpec, targetPaths
  # For flutter-verifier: architectureRef, filePaths, projectRoot
  agentInputs[{A},]{taskId,inputKey,inputValue}:
    {task-id},{inputKey},{inputValue}

  checkpoint:
    @type: Checkpoint
    validation: {validation-criteria}
    rollbackTo: {previous-phase-id}
    onPass: {action}
    onFail: {pause|rollback|continue}

dependencies[{D},]{taskId,dependsOn,reason}:
  {task-id},{dependency-task-id},{reason}

executionOrder[{N}]: {task-id-1},{task-id-2},...,{task-id-N}
