# CLAUDE.md Template for Lucid Toolkit Plugin Users

> **Usage**: Copy this file to your project root as `CLAUDE.md`. Customize the
> "Project-Specific" section and remove plugins you haven't installed from the
> delegation patterns table.

---

## Project-Specific

<!-- Add your project's specific instructions here -->

**Project**: [Your project name]
**Tech Stack**: [e.g., Flutter/Dart, Python, TypeScript]
**Key Directories**:
- `src/` - Source code
- `tests/` - Test files

---

<critical_behavior>
## Context Preservation

Primary goal: Preserve main context by delegating exploration and multi-step work to sub-agents.

Claude's context window is finite. When exhausted mid-task, work is lost. Sub-agents (Task tool) operate in isolated contexts—use them to protect the main conversation.

### Decision Principle

Delegate by default. Execute directly only for simple, certain operations.

**Delegate when (any apply):**
- Location unknown: "find where X happens" → Task(Explore)
- Multi-file operation: "fix X across codebase" → Task(general-purpose)
- Uncertain scope: tool count unclear → Task
- Exploration needed: understanding before acting → Task(Explore)

**Execute directly when (ALL must apply):**
- Single, specific file path already known
- 1-2 tool calls, certain
- No search/exploration component

### Specificity Trap

Specific user input (error messages, function names) without file paths creates false confidence. You know WHAT to find, not WHERE or HOW MANY. Treat specific mutation requests as exploration until locations are confirmed.

Exception: User provides exact file path.

### Transition Awareness

After research (WebSearch, exploratory Read), the next request often asks to ACT on findings. This is the highest-risk moment. Default to delegation when transitioning from research to action.

### Trade-off

False positives (unnecessary delegation) acceptable. Context exhaustion is not.
</critical_behavior>

## Request → Action Matrix

| Request | Action | Rationale |
|---------|--------|-----------|
| "Where is X configured?" | Task(Explore) | Unknown location |
| "Fix [function name]" | Task(general-purpose) | Find + analyze + edit |
| "Error: '[message]' in config" | Task(general-purpose) | Specificity trap |
| "Add import to src/file.ts" | Direct Edit | Known file, single op |
| "What does this file do?" [in context] | Direct answer | Already read |
| "Fix the performance issue" | Ask → Task | Ambiguous, then delegate |
| "Change X to Y in config.ts" | Direct Edit | Specific + location given |

## Constraints

DO NOT:
- Execute multi-file operations directly in main context
- Assume file locations without confirmation
- Guess values, paths, or behaviors when ambiguous
- Add features, refactoring, or "improvements" beyond what was requested

DO:
- Clarify ambiguous requests before acting (AskUserQuestion)
- Use Task(Explore) for any "find where" operations
- Keep solutions minimal and focused on the request
- State conclusions directly without hedging

## Clarification Protocol

**Clarify when:**
- Request has multiple valid interpretations
- Success criteria are undefined
- Technical approach requires choosing between alternatives

**Do not clarify when:**
- Request is clear and actionable
- Standard conventions apply unambiguously

**Precedence:** Ask → Delegate → Direct

---

## Delegation Patterns (Plugin-Specific)

> **Note**: Remove rows for plugins you haven't installed.

Recognize these patterns and delegate immediately:

| User Request Pattern | Delegate To | Plugin Required |
|---------------------|-------------|-----------------|
| "find where X", "search for Y", "what files" | Task(Explore) | (built-in) |
| "update all", "fix across", "refactor everywhere" | Task(general-purpose) | (built-in) |
| "research [topic]", "investigate", "find out" | Task(analyst:research) | analyst |
| "analyze", "think through", "consider options" | Skill(analyst:consider) | analyst |
| "review architecture", "architect review" | Task(architect:architecture-reviewer) | architect |
| "create ADR", "document decision" | Task(architect:adr-writer) | architect |
| "execute plan", "TDD prompt", "implementation plan" | Skill(plan:execution-prompt-generator) | plan |
| "implement [feature]" in Flutter project | Task(impl-flutter:flutter-coder) | impl-flutter |
| "build failed", "CI broken", "flutter doctor" | Task(impl-flutter:flutter-env) | impl-flutter |
| "write tests" in Flutter project | Task(impl-flutter:flutter-tester) | impl-flutter |
| "implement [feature]" in Python project | Task(impl-python:python-coder) | impl-python |
| "debug", "fix error" in Python | Task(impl-python:python-debugger) | impl-python |

### After Completing Work Units

When you've finished a coherent phase (exploration, initial implementation):
- Pause and assess: "Should the next phase be delegated?"
- Prefer delegation for: multi-file changes, long edit sequences, research phases

### Context Protection Rule

If you notice you've done 5+ sequential Edit operations on related files, delegate remaining edits to a subagent to protect main context.

---

## Context Management

### Proactive Compaction (Target: 70-75%)

- Check `/context` after completing each work unit
- Run `/compact` manually when approaching 70% capacity
- Use custom summaries: `/compact preserve the architectural decisions and file patterns`

### Sub-Agent Context Protection

Each subagent gets its own context window. Use this to:
- Offload exploration (Task(Explore))
- Offload multi-file implementations (Task(general-purpose))
- Keep main context for coordination and user communication

### High-Context-Cost Activities (Delegate These)

- Reading large files (>300 lines)
- Test output analysis
- Multi-file exploration
- Long Edit/Read cycles

---

## Parallel Execution

### Parallelize Independent Operations

Launch multiple Task agents simultaneously for independent work:
```
Task(agent-1): "First independent task"
Task(agent-2): "Second independent task"
Task(agent-3): "Third independent task"
```

### Coordinate via progress.md

Create `progress.md` at project root for multi-agent coordination:
```markdown
# Progress Log

## Active Tasks
- [ ] Task description (agent-name)
- [ ] Another task (agent-name)

## Completed
- [x] Completed task
```

### Read Operations (Always Parallelize)

Instead of sequential reads, use parallel tool calls in a single message:
- Multiple Read tools execute in parallel automatically
- Multiple Task tools execute in parallel automatically
- Only serialize when there are dependencies between operations

---

## Path-Based Rules (Optional)

> Add these sections if you want context-specific guidance when working in certain directories.

<!--
Example: Uncomment and customize for your project

---
paths: architecture/decisions/**
---

# ADR Work
When creating or editing Architecture Decision Records:
- Use `/architect adr` for new ADR creation
- Use `architect:adr-writer` agent for structured documentation

---
paths: **/plans/**
---

# Plan Work
When working with execution plans or specifications:
- Use `/plan validate` after editing plan files
- Use `plan:execution-prompt-generator` skill before implementation

---
paths: **/*.dart
---

# Flutter Development
For Dart/Flutter file work:
- Use `impl-flutter:flutter-coder` for feature implementation
- Use `impl-flutter:flutter-tester` for test writing
- Use `impl-flutter:flutter-env` for environment issues
-->
