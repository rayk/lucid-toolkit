# ═══════════════════════════════════════════════════════════════════════════
# SCHEMA: component-info.toon
# ═══════════════════════════════════════════════════════════════════════════
# LCA component inventory tracking Atoms, Composites, Conduits, and
# Deployable Units within a project or service boundary.
# Generated by architect plugin via /architect:init or component-analyzer agent.
#
# ═══════════════════════════════════════════════════════════════════════════
# SCHEMA METADATA
# ═══════════════════════════════════════════════════════════════════════════
#
# $schema: architect/schemas/component-info-schema.toon
# $instance: .claude/component-info.toon
# $generator: /architect:init, component-analyzer agent
# $version: 1.0.0
#
# ═══════════════════════════════════════════════════════════════════════════
# TYPE NOTATION
# ═══════════════════════════════════════════════════════════════════════════
#
#   →const           Fixed value, copy exactly as shown
#   →string          Text value
#   →string?         Optional text (can be null)
#   →int             Integer number
#   →datetime        ISO-8601 timestamp (e.g., 2025-01-15T10:00:00Z)
#   →path            Relative file path
#   →enum[Name]      One of the values in ENUMS section
#   →array<Type>     Tabular array rows
#
# ═══════════════════════════════════════════════════════════════════════════

# ─── METADATA ──────────────────────────────────────────────────────────────

@context: https://schema.org                    # →const
@type: SoftwareSourceCode                       # →const
@id: components/my-project                      # →string (pattern: components/{name})
dateCreated: 2025-01-15T10:00:00Z               # →datetime (immutable after creation)
dateModified: 2025-12-12T14:30:00Z              # →datetime (auto-updated on save)
softwareVersion: 1.0.0                          # →string (architect plugin version)

# ─── PROJECT CONTEXT ──────────────────────────────────────────────────────

project@type: SoftwareSourceCode                # →const
project.name: my-project                        # →string (required)
project.hierarchyLevel: service                 # →enum[HierarchyLevel]
project.architectureDoc: ARCHITECTURE.md        # →path? (link to architecture doc)

# ─── SUMMARY ──────────────────────────────────────────────────────────────

summary@type: ItemList                          # →const
summary.atomCount: 12                           # →int
summary.compositeCount: 4                       # →int
summary.conduitCount: 2                         # →int
summary.deployableUnitCount: 1                  # →int
summary.violationCount: 3                       # →int
summary.lastAnalysis: 2025-12-12T14:30:00Z      # →datetime

# ─── ATOMS ────────────────────────────────────────────────────────────────
# Pure functions, immutable objects, value types. Leaf nodes of composition.

atoms@type: ItemList                            # →const
atoms.numberOfItems: 12                         # →int (count of rows)

# →array<AtomRow> where AtomRow = {name, path, responsibility, purity, confidence}
atom{name,path,responsibility,purity,confidence|tab}:
Validator	src/core/validator.ts:15	Input validation logic	pure	high
Calculator	src/core/calculator.ts:8	Price calculation	pure	high
Formatter	src/utils/formatter.ts:22	Output formatting	pure	medium

# ─── COMPOSITES ───────────────────────────────────────────────────────────
# Containers that orchestrate Atoms. Route data, manage lifecycles.

composites@type: ItemList                       # →const
composites.numberOfItems: 4                     # →int

# →array<CompositeRow> where CompositeRow = {name, path, orchestrates, confidence}
composite{name,path,orchestrates,confidence|tab}:
OrderProcessor	src/services/order-processor.ts:10	Validator,Calculator,Formatter	high
PaymentHandler	src/services/payment-handler.ts:5	Validator,PaymentGateway	medium

# ─── CONDUITS ─────────────────────────────────────────────────────────────
# Distributable boundaries between units. Protocol Buffers, versioned APIs.

conduits@type: ItemList                         # →const
conduits.numberOfItems: 2                       # →int

# →array<ConduitRow> where ConduitRow = {name, path, protocol, version, consumers}
conduit{name,path,protocol,version,consumers|tab}:
OrderAPI	src/api/order.controller.ts:1	rest	v1	web-client,mobile-app
EventBus	src/events/publisher.ts:1	event	v1	analytics-service

# ─── DEPLOYABLE UNITS ─────────────────────────────────────────────────────
# Self-contained services with entry points and deployment config.

units@type: ItemList                            # →const
units.numberOfItems: 1                          # →int

# →array<UnitRow> where UnitRow = {name, path, entryPoint, conduits}
unit{name,path,entryPoint,conduits|tab}:
order-service	./	src/index.ts	OrderAPI,EventBus

# ─── VIOLATIONS ───────────────────────────────────────────────────────────
# LCA principle violations identified during analysis.

violations@type: ItemList                       # →const
violations.numberOfItems: 3                     # →int

# →array<ViolationRow> where ViolationRow = {type, location, description, severity, status}
violation{type,location,description,severity,status|tab}:
inheritance-behavior	src/models/base-entity.ts:5	Using class inheritance for shared behavior	high	open
composite-logic	src/services/order-processor.ts:45	Business logic in composite method	medium	open
atom-side-effect	src/core/logger.ts:10	Atom performs I/O operations	medium	acknowledged

# ─── ANALYSIS HISTORY ─────────────────────────────────────────────────────

history@type: ItemList                          # →const
history.numberOfItems: 2                        # →int

# →array<AnalysisRow> where AnalysisRow = {datetime, atomCount, violationCount, trigger}
analysis{datetime,atomCount,violationCount,trigger|tab}:
2025-12-12T14:30:00Z	12	3	manual
2025-12-01T10:00:00Z	10	5	init


# ═══════════════════════════════════════════════════════════════════════════
# ENUMS
# ═══════════════════════════════════════════════════════════════════════════

# HierarchyLevel (LCA documentation hierarchy):
#   platform          - Cross-cutting concerns, multiple services
#   repository        - Single codebase with modules
#   service           - Focused microservice or application
#   component         - Part of larger service

# PurityLevel (Atom purity assessment):
#   pure              - No side effects, deterministic
#   mostly-pure       - Minimal side effects, isolated
#   impure            - Has side effects (should not be Atom)

# ConfidenceLevel (Classification confidence):
#   high              - Clear match to LCA type
#   medium            - Likely match, needs verification
#   low               - Uncertain, requires review

# ViolationType (LCA violation categories):
#   inheritance-behavior    - Using inheritance for behavior sharing
#   composite-logic         - Business logic in Composite
#   atom-side-effect        - Side effects in Atom
#   unversioned-conduit     - API without version
#   circular-dependency     - Components depend on each other
#   missing-boundary        - No Conduit at service edge
#   tight-coupling          - Direct instantiation

# ViolationStatus (Violation tracking):
#   open              - Not yet addressed
#   acknowledged      - Known, intentional deviation
#   resolved          - Fixed
#   wont-fix          - Decided not to fix (requires ADR)

# ProtocolType (Conduit protocol):
#   rest              - REST API
#   grpc              - gRPC with Protocol Buffers
#   graphql           - GraphQL API
#   event             - Event/message-based
#   rpc               - Other RPC mechanism


# ═══════════════════════════════════════════════════════════════════════════
# GENERATION RULES
# ═══════════════════════════════════════════════════════════════════════════
#
# 1. Fields marked →const MUST be copied exactly as shown
# 2. Fields marked TYPE? can be null - write as: fieldName: null
# 3. Tabular arrays use TAB character (\t) between columns
# 4. Empty arrays: keep header line, omit data rows
# 5. Update numberOfItems to match actual row count
# 6. Update dateModified and summary counts on every save
# 7. Violation status should be tracked across analyses
# 8. path column should include line number where applicable (file.ts:line)
# 9. orchestrates column in composites is comma-separated atom names
# 10. consumers column in conduits is comma-separated consumer names
#
# ═══════════════════════════════════════════════════════════════════════════
